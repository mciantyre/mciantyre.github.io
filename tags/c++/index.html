<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>C&#43;&#43;</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	<link rel="alternate" type="application/rss+xml" href="/tags/c++/index.xml" title="mciantyre">
</head>
<body>
	<header>
	<a href="http://mciantyre.github.io/">mciantyre</a>
	
	<nav>
		<ul>
			
			<li><a href="/tags">Tags</a></li>
			
		</ul>
	</nav>
	
</header>

	
	<main>
		
		<div>
			<h1>C&#43;&#43;</h1>
			
		</div>
		

		
			<article>
	<h1><a href="http://mciantyre.github.io/post/2018-03-16-cpp-strong-exception-masks/">Safer configuration and exception masks in C&#43;&#43;</a></h1>
	<time>16.03.2018 09:00</time>
	
	<a href="/tags/c&#43;&#43;">C&#43;&#43;</a>
	
	<a href="/tags/embedded">embedded</a>
	
	<div>
		In embedded C software, it's typical to see configurations and exceptions represented as bitmasks. The approach allows us to configure ON/OFF setting in a space-efficient manner. We work with the masks using bitwise AND and OR, checking and setting bits as required.
#define	SPI_MODE_CKPOL_HIGH (1 &lt;&lt; 8)#define	SPI_MODE_CKPHASE_HALF (1 &lt;&lt; 9)#define	SPI_MODE_BODER_MSB (1 &lt;&lt; 10)#define	SPI_MODE_CSPOL_HIGH (1 &lt;&lt; 11)#define	SPI_MODE_CSSTAT_HIGH (1 &lt;&lt; 12)#define	SPI_MODE_CSHOLD_HIGH (1 &lt;&lt; 13) typedef spi_cfg unsigned int; int spi_cfg(int fd, int dev, spi_cfg cfg); Above: real-life SPI configuration bits indended for setting device settings.
		
			<a href="http://mciantyre.github.io/post/2018-03-16-cpp-strong-exception-masks/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="http://mciantyre.github.io/post/2017-09-29-singleton-policy/">On the singleton pattern in C&#43;&#43;: Policy-based design</a></h1>
	<time>29.09.2017 09:00</time>
	
	<a href="/tags/c&#43;&#43;">C&#43;&#43;</a>
	
	<div>
		In a previous post, we talked about units that use dependency injection to indirectly access singletons, as opposed to units that directly call on global singletons. In our design, a singleton implements an interface, and units accept a reference to the interface type. The design is easier to test, maintain, and refactor.
In this brief follow-up, we'll explore an alternative approach that applies specifically to C++: templates and &ldquo;policy-based design.&rdquo; Policy-based design comes from Alexandrescu's Modern C++ Design (2001).
		
			<a href="http://mciantyre.github.io/post/2017-09-29-singleton-policy/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="http://mciantyre.github.io/post/2017-09-24-cpp-singletons/">On the singleton pattern in C&#43;&#43;</a></h1>
	<time>24.09.2017 21:23</time>
	
	<a href="/tags/c&#43;&#43;">C&#43;&#43;</a>
	
	<div>
		The singleton pattern controls the creation and access of data. It is a popular design pattern that I've used and seen used in a variety of software designs. However, I cringe when I see a singleton being accessed willy-nilly, just as one would access mutable, global state.
int MyThing::DoSomething(int x) { m_value += x; // :( v-- sadness  if (!Logging::Instance().Log(LogMsg::Result, m_value)) return -1 return m_value; } How do I test this?
		
			<a href="http://mciantyre.github.io/post/2017-09-24-cpp-singletons/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="http://mciantyre.github.io/post/2017-09-20-cpp-promises-futures/">C&#43;&#43; promises and futures</a></h1>
	<time>20.09.2017 19:27</time>
	
	<a href="/tags/c&#43;&#43;">C&#43;&#43;</a>
	
	<div>
		The C++11 standard introduced std::promise and std::future as a mechanism for concurrent programming. The promise-future pattern is similar to what you find in JavaScript: a &ldquo;promise&rdquo; denotes the fulfillment of a computation, and the &ldquo;future&rdquo; defines means of accessing the computation's result. The pair can be used for memory-safe communication across threads and for defining asynchronous tasks.
Let's explore std::promise and std::future, as well as some modern C++ concepts and standard library components, by creating a basic promise-future paring.
		
			<a href="http://mciantyre.github.io/post/2017-09-20-cpp-promises-futures/">Read more...</a>
		
	</div>
</article>

		
			<article>
	<h1><a href="http://mciantyre.github.io/post/2017-09-17-cpp-compile-lang-lookup/">Safe language string selection in C&#43;&#43;11</a></h1>
	<time>17.09.2017 18:29</time>
	
	<a href="/tags/c&#43;&#43;">C&#43;&#43;</a>
	
	<div>
		I'm working on a legacy C codebase for an embedded system. The devices is sold in different countries and has to support different languages. Although we can set a default language at build time, the end-user is able to change the language by navigating through a few graphical menus. She'll see all the strings update immediately on the user interface.
As might be expected when dealing with legacy code, my teammates and I ran into issues when adding language strings to the codebase.
		
			<a href="http://mciantyre.github.io/post/2017-09-17-cpp-compile-lang-lookup/">Read more...</a>
		
	</div>
</article>

		
		<div>

1 of 1

</div>

	</main>
<aside>
	<div>
		<div>
			<h3>LATEST POSTS</h3>
		</div>
		<div>
			<ul>
				
				<li><a href="/post/2018-03-16-cpp-strong-exception-masks/">Safer configuration and exception masks in C&#43;&#43;</a></li>
				
				<li><a href="/post/2018-03-04-devops-foosball-cicd/">Devops for foosball: CI and CD</a></li>
				
				<li><a href="/post/2017-09-29-singleton-policy/">On the singleton pattern in C&#43;&#43;: Policy-based design</a></li>
				
				<li><a href="/post/2017-09-24-cpp-singletons/">On the singleton pattern in C&#43;&#43;</a></li>
				
				<li><a href="/post/2017-09-20-cpp-promises-futures/">C&#43;&#43; promises and futures</a></li>
				
			</ul>
		</div>
	</div>
</aside>


	<footer>
	<p>&copy; 2019 <a href="http://mciantyre.github.io/">mciantyre</a></p>
</footer>

</body>
</html>
